using RetroBatMarqueeManager.Core.Interfaces;
using RetroBatMarqueeManager.Infrastructure.Native;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Drawing;
using System.Drawing.Imaging;

namespace RetroBatMarqueeManager.Application.Services
{
    public class DmdService : IDmdService, IDisposable
    {
        private readonly IConfigService _config;
        private readonly IProcessService _processService;
        private readonly ILogger<DmdService> _logger;
        private readonly ImageConversionService _imageService;
        private readonly DmdDeviceWrapper _dmdWrapper;

        private Process? _currentDmdProcess;
        private string _dmdDeviceIniPath;
        private bool _isNativeOpen = false;
        private string? _lastMediaPath = null;
        private CancellationTokenSource? _animationCts = null;
        private bool _isExternalControlActive = false;

        public DmdService(
            IConfigService config, 
            IProcessService processService, 
            ImageConversionService imageService, 
            DmdDeviceWrapper dmdWrapper,
            ILogger<DmdService> logger)
        {
            _config = config;
            _processService = processService;
            _imageService = imageService;
            _dmdWrapper = dmdWrapper;
            _logger = logger;
            
            var dmdDir = Path.GetDirectoryName(config.DmdExePath);
            if (string.IsNullOrEmpty(dmdDir)) dmdDir = AppDomain.CurrentDomain.BaseDirectory;
            _dmdDeviceIniPath = Path.Combine(dmdDir, "DmdDevice.ini");
        }

        public async Task InitializeAsync()
        {
            if (!_config.DmdEnabled)
            {
                _logger.LogInformation("DMD support is disabled in config.");
                return;
            }

            // Always prepare config
            PrepareConfig();

            // Try to load Native DLL
            var dmdDir = Path.GetDirectoryName(_config.DmdExePath);
            if (!string.IsNullOrEmpty(dmdDir))
            {
                 if (_dmdWrapper.Load(dmdDir))
                 {
                     _logger.LogInformation("Native DMD Driver Loaded.");
                     _logger.LogInformation("Native DMD Driver Loaded.");
                     _isExternalControlActive = false;
                     await EnsureNativeOpenAsync();
                 }
                 else
                 {
                     _logger.LogWarning("Failed to load Native DMD Driver. Will fallback to CLI only.");
                 }
            }
            
            // Play Default Media on Startup
            if (!string.IsNullOrEmpty(_config.DefaultDmdPath) && File.Exists(_config.DefaultDmdPath))
            {
                _logger.LogInformation($"Playing Default DMD Media: {_config.DefaultDmdPath}");
                // Await default playback
                await PlayAsync(_config.DefaultDmdPath);
            }
        }

        public string PrepareConfig()
        {
             // EN: Update DmdDevice.ini intelligently (preserve other settings)
             // FR: Mettre à jour DmdDevice.ini intelligemment (préserver les autres paramètres)
             
             try
             {
                 var lines = new List<string>();
                 if (File.Exists(_dmdDeviceIniPath))
                 {
                     lines = File.ReadAllLines(_dmdDeviceIniPath).ToList();
                 }
                 else
                 {
                     // Create skeleton if missing
                     lines.Add("; Generated by RetroBatMarqueeManager");
                     lines.Add("[global]");
                     lines.Add("resize = 128x32");
                     lines.Add("flip_horizontally = false");
                     lines.Add("flip_vertically = false");
                     lines.Add("");
                 }
                 
                // Helper to update or insert key in section (and remove duplicates)
                 void UpdateKey(string section, string key, string value)
                 {
                     int sectionIdx = -1;
                     // Find section
                     for (int i = 0; i < lines.Count; i++)
                     {
                         if (lines[i].Trim().Equals($"[{section}]", StringComparison.OrdinalIgnoreCase))
                         {
                             sectionIdx = i;
                             break;
                         }
                     }
                     
                     if (sectionIdx == -1)
                     {
                         // Section missing, append it
                         lines.Add("");
                         lines.Add($"[{section}]");
                         lines.Add($"{key} = {value}");
                         return;
                     }
                     
                     // Scan keys in section
                     bool keyUpdated = false;
                     List<int> linesToRemove = new List<int>();
                     
                     for (int i = sectionIdx + 1; i < lines.Count; i++)
                     {
                         var line = lines[i].Trim();
                         if (line.StartsWith("[")) break; // End of section
                         
                         // Check for Key match (ignore comments starting with ;)
                         // We strictly match "key =" or "key="
                         if (line.StartsWith(key + " =", StringComparison.OrdinalIgnoreCase) || 
                             line.StartsWith(key + "=", StringComparison.OrdinalIgnoreCase))
                         {
                             if (!keyUpdated)
                             {
                                 lines[i] = $"{key} = {value}";
                                 keyUpdated = true;
                             }
                             else
                             {
                                 // Duplicate key found later in section! Remove it to prevent override.
                                 linesToRemove.Add(i);
                             }
                         }
                     }
                     
                     // Remove duplicates in reverse order
                     for (int j = linesToRemove.Count - 1; j >= 0; j--)
                     {
                         lines.RemoveAt(linesToRemove[j]);
                     }
                     
                     if (!keyUpdated)
                     {
                         lines.Insert(sectionIdx + 1, $"{key} = {value}");
                     }
                 }
                 
                // 1. GLOBAL: Update Resize
                // DmdDevice 2.0+ expects Fit, Fill, or Stretch. Legacy used WxH.
                // Reverting to WxH because 'Fit' causes crash with GIFs on VirtualDMD?
                // FR: Retour à WxH car 'Fit' semble planter le VirtualDMD avec des GIFs
                UpdateKey("global", "resize", "Fit");
                 
                // 2. MODELS: Enable/Disable based on selection
                var selectedModel = _config.DmdModel.ToLowerInvariant();
                
                // IMPORTANT: Map "virtual" to "virtualdmd" section for correct dot-matrix rendering
                // "virtual" section has upscaling which gives flat screen appearance
                // "virtualdmd" section gives proper DMD pixel/dot rendering
                if (selectedModel == "virtual")
                {
                    selectedModel = "virtualdmd";
                }
                
                // Comprehensive list of sections in DmdDevice.ini to manage
                var knownModels = new[] { 
                    "virtual", "virtualdmd", 
                    "pin2dmd", 
                    "zedmd", "zedmdhd", "zedmdwifi", "zedmdhdwifi", 
                    "pindmdv1", "pindmdv2", "pindmdv3", 
                    "pixelcade", "alphanumeric", 
                    "pinup", 
                    "rawoutput", 
                    "networkstream", "browserstream", "vpdbstream" 
                };
                 
                 foreach (var model in knownModels)
                 {
                     bool isEnabled = (model == selectedModel);
                     

                     
                     UpdateKey(model, "enabled", isEnabled ? "true" : "false");
                 }

                File.WriteAllLines(_dmdDeviceIniPath, lines);
                _logger.LogInformation($"Updated DmdDevice.ini: set global.resize=Fit, {selectedModel}.enabled=true (others false)");
                
                // CRITICAL: Set Variable in USER scope so external processes (PinballFX, etc.) can see it!
                // EN: External game processes need to find DmdDevice.ini via this env variable
                // FR: Les processus de jeux externes ont besoin de trouver DmdDevice.ini via cette variable
                Environment.SetEnvironmentVariable("DMDDEVICE_CONFIG", _dmdDeviceIniPath, EnvironmentVariableTarget.User);
                _logger.LogInformation($"Set DMDDEVICE_CONFIG environment variable (User scope): {_dmdDeviceIniPath}");
            }
            catch (Exception ex)
            {
                _logger.LogError($"Failed to update DmdDevice.ini: {ex.Message}");
            }
            
            return _dmdDeviceIniPath;
        }

        private async Task EnsureNativeOpenAsync()
        {
            if (!_dmdWrapper.IsLoaded) return;

            // If CLI process is running, stop it first to free device
            StopCliProcess();

            if (!_isNativeOpen)
            {
                 // EN: Add safety delay to ensure USB device is fully released by external process (dmdext)
                 // FR: Ajouter un délai de sécurité pour s'assurer que le périphérique USB est libéré par le processus externe
                 await Task.Delay(200);

                int result = _dmdWrapper.Open();
                if (result >= 0) // usually 0 or count on success 
                {
                    _isNativeOpen = true;
                    _logger.LogInformation("Native DMD Device Opened.");

                    // EN: Send a CLEAR frame immediately to reset hardware state (Fix for ZeDMD screen frozen/black)
                    // FR: Envoyer une frame CLEAR immédiatement pour réinitialiser l'état du matériel
                    try 
                    {
                        var clearBytes = new byte[_config.DmdWidth * _config.DmdHeight * 3]; // Black (Zeros)
                        _dmdWrapper.Render((ushort)_config.DmdWidth, (ushort)_config.DmdHeight, clearBytes);
                        _logger.LogInformation("[DMD] Sent Clear Frame on Open.");
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning($"[DMD] Failed to send Clear Frame: {ex.Message}");
                    }
                }
                else
                {
                    _logger.LogError($"Failed to Open Native DMD Device. Result code: {result}");
                }
            }
        }

        private void EnsureNativeClosed()
        {
            if (_isNativeOpen)
            {
                _dmdWrapper.Close();
                _isNativeOpen = false;
                _logger.LogInformation("Native DMD Device Closed.");
            }
        }

        private void StopCliProcess()
        {
            if (_currentDmdProcess != null && !_currentDmdProcess.HasExited)
            {
                try
                {
                    _currentDmdProcess.Kill();
                    _currentDmdProcess.Dispose();
                }
                catch (Exception ex)
                {
                    _logger.LogWarning($"Failed to kill DMD CLI process: {ex.Message}");
                }
                finally
                {
                    _currentDmdProcess = null;
                }
            }
             // Ensure stray dmdext fallback
            try { _processService.KillProcess("dmdext"); } catch {}
        }

        public async Task PlayAsync(string mediaPath, string? system = null, string? gameName = null)
        {
            await PlayInternalAsync(mediaPath, system, gameName);
        }

        // Switched to Async internally but keeping Interface void for now (or fire-and-forget)
        private async Task PlayInternalAsync(string mediaPath, string? system = null, string? gameName = null)
        {
            if (string.IsNullOrEmpty(mediaPath)) return;
            
            // Optimization: If same media is already playing, don't restart
            if (_lastMediaPath == mediaPath && (_isNativeOpen || (_currentDmdProcess != null && !_currentDmdProcess.HasExited) || _animationCts != null))
            {
                return;
            }

            // EN: Protection against overriding external processes (e.g., Pinball)
            // FR: Protection contre l'écrasement de processus externes (ex: Pinball)
            if (_isExternalControlActive)
            {
                _logger.LogWarning($"[DMD Protected] Leaving DMD alone because external control is active. Request for '{Path.GetFileName(mediaPath)}' ignored.");
                return;
            }

            _lastMediaPath = mediaPath;

            // Fix: Clean state for new playback
            StopCliProcess();
            StopAnimation();

            if (!_config.DmdEnabled) return;
            if (!File.Exists(mediaPath)) return;

            string ext = Path.GetExtension(mediaPath).TrimStart('.').ToLowerInvariant();
            bool isVideo = new[] { "gif", "mp4", "avi", "webm", "mkv" }.Contains(ext);
            
            _logger.LogInformation($"[DMD Play] Request: {mediaPath} (Ext={ext}, IsVideo={isVideo}, NativeLoaded={_dmdWrapper.IsLoaded})");
            
            // Special handling for MP4: User requests conversion to Animated GIF for cached playback
            if (ext == "mp4")
            {
                var processedPath = _imageService.ProcessDmdImage(mediaPath, "defaults", system, gameName);
                if (!string.IsNullOrEmpty(processedPath) && File.Exists(processedPath))
                {
                    mediaPath = processedPath;
                    ext = Path.GetExtension(mediaPath).TrimStart('.').ToLowerInvariant();
                    isVideo = new[] { "gif", "mp4", "avi", "webm", "mkv" }.Contains(ext);
                }
                else
                {
                    _logger.LogWarning($"[DMD Play] MP4 conversion failed for {mediaPath}. Aborting playback (dmdext does not support raw MP4).");
                    return;
                }
            }

            if (_dmdWrapper.IsLoaded)
            {
                // Determine grayscale mode
                bool useGrayscale = false;
                string methodName = _dmdWrapper.RenderMethodName ?? "";
                if (methodName.Contains("16_Shades") || methodName.Contains("4_Shades") || 
                    methodName.Contains("Gray", StringComparison.OrdinalIgnoreCase) ||
                    methodName.Contains("Grey", StringComparison.OrdinalIgnoreCase))
                {
                    useGrayscale = true;
                }
                if (_config.GetSetting("DmdForceMono", "false") == "true")
                {
                    useGrayscale = true;
                }

                if (ext == "gif")
                {
                    // NATIVE GIF PATH (0 Latency)
                    StartNativeGifAnimation(mediaPath, useGrayscale);
                    return;
                }

                if (!isVideo)
                {
                    // NATIVE STATIC PATH
                    await EnsureNativeOpenAsync();
                    try 
                    {
                        var bytes = await _imageService.GetRawDmdBytes(mediaPath, _config.DmdWidth, _config.DmdHeight, useGrayscale);
                        if (bytes != null && bytes.Length > 0)
                        {
                             // Fix for Render_16_Shades
                             if (useGrayscale && (_dmdWrapper.RenderMethodName?.Contains("16_Shades") == true))
                             {
                                 for (int i = 0; i < bytes.Length; i++) bytes[i] = (byte)(bytes[i] >> 4);
                             }
                             
                             _currentStaticBytes = bytes; // Store for overlay composition
                             RenderStaticWithOverlay(useGrayscale); // Use RenderStaticWithOverlay to handle active overlay
                        }
                    }
                    catch (Exception ex) { _logger.LogError($"Native Render Error: {ex.Message}"); }
                    return;
                }
            }

            // CLI PATH (Fallback for Video or if Native failed)
            EnsureNativeClosed(); 
            StartCliProcess(mediaPath);
        }

        public async Task<(bool handled, bool suspendMPV)> CheckAndRunPinballAsync(string system, string gameName)
        {
            if (!_config.DmdEnabled) return (false, false);

            var command = _config.GetSetting(system);
            if (string.IsNullOrWhiteSpace(command)) return (false, false);

            // EN: Parse format: command[;handleDMD][;suspendMPV]
            // FR: Parser le format : commande[;handleDMD][;suspendMPV]
            var parts = command.Split(';');
            var actualCommand = parts[0].Trim();
            var handleDMD = parts.Length > 1 && parts[1].Trim().Equals("True", StringComparison.OrdinalIgnoreCase);
            var suspendMPV = parts.Length > 2 && parts[2].Trim().Equals("True", StringComparison.OrdinalIgnoreCase);

            _logger.LogInformation($"[Pinball] System '{system}' match found. Command: {actualCommand}, HandleDMD: {handleDMD}, SuspendMPV: {suspendMPV}");

            if (actualCommand.Equals("True", StringComparison.OrdinalIgnoreCase))
            {
                _logger.LogInformation($"[Pinball] External handling requested for '{system}'. Internal DMD stopped. SuspendMPV: {suspendMPV}");
                // stop internal DMD
                Stop();
                _isExternalControlActive = true;
                _logger.LogInformation("[DMD Protected] External control activated.");
                return (true, suspendMPV);
            }

            // Replace Placeholders
            actualCommand = actualCommand.Replace("{DmdModel}", _config.DmdModel, StringComparison.OrdinalIgnoreCase)
                             .Replace("{GameName}", gameName, StringComparison.OrdinalIgnoreCase);

            // Zaccaria Position Logic
            if (actualCommand.Contains("!POSITION!"))
            {
                var pos = await GetZaccariaPosition(gameName);
                if (!string.IsNullOrEmpty(pos))
                {
                    actualCommand = actualCommand.Replace("!POSITION!", pos);
                }
                else
                {
                    _logger.LogWarning($"[Pinball] Could not find position for '{gameName}' in Zaccaria positions.txt. Aborting.");
                    return (true, suspendMPV); 
                }
            }

            // Launch Command
            try
            {
                _logger.LogInformation($"[Pinball] Launching Custom Command: {actualCommand}");
                
                var cmdParts = actualCommand.Split(" ", 2);
                var fileName = cmdParts[0];
                var args = cmdParts.Length > 1 ? cmdParts[1] : "";

                if (fileName.Equals("dmdext.exe", StringComparison.OrdinalIgnoreCase))
                {
                    fileName = _config.DmdExePath;
                    
                    // EN: Special fix for Zaccaria Pinball: Ensure --quit-when-done is present if not already
                    // FR: Fix spécial pour Zaccaria Pinball : S'assurer que --quit-when-done est présent
                    if (system.Contains("zaccaria", StringComparison.OrdinalIgnoreCase) && 
                        !args.Contains("--quit-when-done", StringComparison.OrdinalIgnoreCase))
                    {
                         args += " --quit-when-done";
                         _logger.LogInformation("[Pinball] Automatically added --quit-when-done for Zaccaria Pinball.");
                    }
                }

                // EN: Close native driver to release DMD device for CLI process
                // FR: Fermer le driver natif pour libérer le périphérique DMD pour le processus CLI
                StopAnimation(); // Ensure internal animation is stopped
                EnsureNativeClosed();
                
                // EN: Wait for ZeDMD full restart (takes 1-2 seconds for hardware reset)
                // FR: Attendre le redémarrage complet du ZeDMD (1-2 secondes pour reset matériel)
                // _logger.LogInformation("[Pinball] Waiting 2s for ZeDMD restart...");
                // await Task.Delay(2000); // Optimized: User confirmed delay might not be needed.
                await Task.Delay(100); // Small safety buffer only
                
                _logger.LogInformation("[Pinball] Launching CLI command...");
                
                if (StartCliProcessCustom(fileName, args))
                {
                    _isExternalControlActive = true;
                    _logger.LogInformation("[DMD Protected] External control activated (CLI launched).");
                }
                else
                {
                    _logger.LogWarning("[Pinball] Failed to launch CLI command - DMD Protection NOT activated.");
                    _isExternalControlActive = false; // Ensure it's false
                }
                
                // EN: Try to bring game window to front if it lost focus during launch
                // FR: Essayer de remettre la fenêtre du jeu au premier plan si elle a perdu le focus au lancement
                // Using system name as heuristic for process name if needed, or Zaccaria specifically
                if (system.Contains("zaccaria", StringComparison.OrdinalIgnoreCase))
                {
                    // "ZaccariaPinball.exe" is the usual name
                    await Task.Delay(500); // Wait a bit for window activation if any
                    _processService.FocusProcess("ZaccariaPinball"); 
                }
                
                return (true, suspendMPV);
            }
            catch (Exception ex)
            {
                _logger.LogError($"[Pinball] Failed to launch custom command: {ex.Message}");
                return (true, suspendMPV);
            }
        }

        private async Task<string?> GetZaccariaPosition(string gameName)
        {
            try
            {
                var dmdDir = Path.GetDirectoryName(_config.DmdExePath);
                if (string.IsNullOrEmpty(dmdDir)) return null;

                var posFile = Path.Combine(dmdDir, "zaccariapinball", "positions.txt");
                if (!File.Exists(posFile))
                {
                    _logger.LogWarning($"[Pinball] Positions file not found: {posFile}");
                    return null;
                }

                var lines = await File.ReadAllLinesAsync(posFile);
                foreach (var line in lines)
                {
                    // Format: GameName:Position
                    // Example: Game Name:100 100 500 200
                    var parts = line.Split(':', 2);
                    if (parts.Length == 2)
                    {
                        if (parts[0].Trim().Equals(gameName, StringComparison.OrdinalIgnoreCase))
                        {
                            return parts[1].Trim();
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"[Pinball] Error reading positions.txt: {ex.Message}");
            }
            return null;
        }

        private bool StartCliProcessCustom(string fileName, string args)
        {
             StopCliProcess();

             try
             {
                var startInfo = new ProcessStartInfo
                {
                    FileName = fileName,
                    Arguments = args,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    WorkingDirectory = AppDomain.CurrentDomain.BaseDirectory,
                    RedirectStandardError = true,
                    RedirectStandardOutput = true
                };
                
                // Pass environment config for dmdext
                startInfo.EnvironmentVariables["DMDDEVICE_CONFIG"] = _dmdDeviceIniPath;

                _currentDmdProcess = new Process { StartInfo = startInfo };
                _currentDmdProcess.EnableRaisingEvents = true; // Enable Exited event

                _currentDmdProcess.OutputDataReceived += (s, e) => { if (e.Data != null) _logger.LogInformation($"[DMD EXT (Custom) STDOUT] {e.Data}"); };
                _currentDmdProcess.ErrorDataReceived += (s, e) => { if (e.Data != null) _logger.LogError($"[DMD EXT (Custom) STDERR] {e.Data}"); };
                _currentDmdProcess.Exited += (s, e) => 
                {
                    _logger.LogWarning($"[DMD EXT (Custom)] Process exited with code: {_currentDmdProcess.ExitCode}");
                    _isExternalControlActive = false; // Release lock if process dies
                };

                _currentDmdProcess.Start();

                _currentDmdProcess.BeginOutputReadLine();
                _currentDmdProcess.BeginErrorReadLine();
                
                return true;
             }
             catch(Exception ex)
             {
                 _logger.LogError($"[Pinball] StartCliProcessCustom Failed: {ex.Message}");
                 return false;
             }
        }

        private void StartCliProcess(string mediaPath)
        {
            StopCliProcess(); // Stop previous

             try
            {
                var args = $"play -f \"{mediaPath}\"";
                
                // --- ARGUMENT GENERATION ---
                // "Si commenté [empty] -> Mode Automatique. Si décommenté [value] -> Mode Autonome"
                
                string userArgs = _config.DmdArguments; // Sanitized by IDmdConfigService logic regarding --format if present

                if (!string.IsNullOrWhiteSpace(userArgs))
                {
                    // MANUAL MODE (Partial or Full Autonomy)
                    // We append what the user provided.
                    // We DO NOT add -d automatically, assuming user might have provided it or wants default.
                    // We DO NOT add position/stay-on-top defaults.
                    
                    // Safety: Sanitize --format if it crept in, as it crashes 'play'
                    var cleanArgs = userArgs
                        .Replace("--format rgb24", "", StringComparison.OrdinalIgnoreCase)
                        .Replace("--format", "", StringComparison.OrdinalIgnoreCase);

                    args += $" {cleanArgs}";
                    _logger.LogDebug($"[DMD CLI] Manual Arguments Used: {cleanArgs}");
                }
                else
                {
                    // AUTO MODE (Default)
                    
                    var model = _config.DmdModel.ToLowerInvariant();
                    
                    // Check if this is a virtual/software DMD or physical hardware
                    var virtualModels = new[] { "virtual", "virtualdmd" };
                    bool isVirtualModel = virtualModels.Contains(model);
                    
                    if (isVirtualModel)
                    {
                        // VIRTUAL DMD: Use --virtual-position (no -d flag needed for play command)
                        // According to official documentation, --virtual-position automatically enables virtual DMD
                        
                        // Calculate window size using DmdDotSize as scaling factor
                        // This allows keeping DmdWidth/Height as rendering resolution (128x32)
                        // while displaying in a larger window (e.g., 1024x256 with DmdDotSize=8)
                        int windowWidth = (int)(_config.DmdWidth * _config.DmdDotSize);
                        int windowHeight = (int)(_config.DmdHeight * _config.DmdDotSize);
                        
                        // Position & Options
                        args += $" --virtual-position 0 0 {windowWidth} {windowHeight} --virtual-stay-on-top";
                    }
                    else
                    {
                        // PHYSICAL HARDWARE DMD: Use -d flag with the configured model
                        // Examples: zedmd, pin2dmd, pindmdv3, etc.
                        args += $" -d {model}";
                        _logger.LogInformation($"[DMD CLI] Using hardware destination: {model}");
                    }
                }
                
                _logger.LogInformation($"[DMD CLI] Launching: {_config.DmdExePath} {args}");
                
                var startInfo = new ProcessStartInfo
                {
                    FileName = _config.DmdExePath,
                    Arguments = args,
                    UseShellExecute = false,
                    CreateNoWindow = true, 
                    WorkingDirectory = AppDomain.CurrentDomain.BaseDirectory,
                    RedirectStandardError = true,
                    RedirectStandardOutput = true
                };

                startInfo.EnvironmentVariables["DMDDEVICE_CONFIG"] = _dmdDeviceIniPath;

                _currentDmdProcess = new Process { StartInfo = startInfo };
                
                _currentDmdProcess.OutputDataReceived += (s, e) => { if (e.Data != null) _logger.LogInformation($"[DMD EXT STDOUT] {e.Data}"); };
                _currentDmdProcess.ErrorDataReceived += (s, e) => { if (e.Data != null) _logger.LogError($"[DMD EXT STDERR] {e.Data}"); };

                _currentDmdProcess.Start();
                
                _currentDmdProcess.BeginOutputReadLine(); // Drain buffers to avoid lock
                _currentDmdProcess.BeginErrorReadLine();
            }
            catch (Exception ex)
            {
                _logger.LogError($"Failed to start DMD CLI: {ex.Message}");
            }
        }

        public async Task WaitForExternalReleaseAsync(int timeoutMs = 2000)
        {
            // EN: Safety check: If lock is active but no process is running (Manual Mode or Crash), release immediately.
            // FR: Vérification de sécurité : Si le verrou est actif mais qu'aucun processus ne tourne, libérer immédiatement.
            bool isProcessRunning = false;
            try 
            {
                if (_currentDmdProcess != null && !_currentDmdProcess.HasExited) isProcessRunning = true;
            } 
            catch {}

            if (_isExternalControlActive && !isProcessRunning)
            {
                _logger.LogInformation("[DMD] External control active but no managed process running (Manual Mode detected). Force releasing.");
                _isExternalControlActive = false;
            }

            if (!_isExternalControlActive)
            {
                await EnsureNativeOpenAsync();
                return;
            }

            _logger.LogInformation($"[DMD] Waiting up to {timeoutMs}ms for external control release...");
            int elapsed = 0;
            int interval = 50;
            while (_isExternalControlActive && elapsed < timeoutMs)
            {
                await Task.Delay(interval);
                elapsed += interval;
            }

            if (_isExternalControlActive)
            {
                 _logger.LogWarning("[DMD] Timeout waiting for external control release. Forcing takeover.");
                 StopCliProcess(); // Kill any stuck process
                 _isExternalControlActive = false;
                 await EnsureNativeOpenAsync();
            }
            else
            {
                _logger.LogInformation("[DMD] External control released.");
                // EN: Proactively open native driver to reset hardware
                // FR: Ouvrir proactivement le driver natif pour réinitialiser le matériel
                await EnsureNativeOpenAsync();
            }
        }

        public void Stop()
        {
            _isExternalControlActive = false; // Reset protection on explicit Stop()
            StopCliProcess();
            StopAnimation();
            EnsureNativeClosed(); // EN: Also close native driver to fully release DMD device / FR: Fermer aussi le driver natif pour libérer complètement le périphérique DMD
        }

        public void Dispose()
        {
            StopCliProcess();
            StopAnimation();
            EnsureNativeClosed();
            _dmdWrapper.Dispose();
            GC.SuppressFinalize(this);
        }

        private void StopAnimation()
        {
            try
            {
                if (_animationCts != null)
                {
                    _animationCts.Cancel();
                    _animationCts.Dispose();
                    _animationCts = null;
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning($"Error stopping DMD animation: {ex.Message}");
            }
        }

        private byte[]? _activeOverlayBytes;
        private DateTime? _overlayExpiry;
        private readonly object _overlayLock = new object();
        private byte[]? _currentStaticBytes; // Store current static image for composition
        
        public async Task PlayAchievementSequenceAsync(string cupPath, string badgePath, string text, int totalDurationMs = 10000)
        {
             // 1. Show Cup (2s)
             if (!string.IsNullOrEmpty(cupPath) && File.Exists(cupPath))
             {
                 await SetOverlayAsync(cupPath, 2000);
                 await Task.Delay(2000);
             }
             
             // 2. Scroll Text (Variable duration, aim for 3-4s, but depends on length)
             // Generate frames first to be ready
             bool useGrayscale = _config.GetSetting("DmdForceMono", "false") == "true";
             // Check native for grayscale hint
             if (_isNativeOpen && _dmdWrapper.IsLoaded)
             {
                 var method = _dmdWrapper.RenderMethodName ?? "";
                 if (method.Contains("Gray") || method.Contains("16_Shades") || method.Contains("4_Shades")) useGrayscale = true;
             }

             var textFrames = _imageService.GenerateDmdScrollingTextFrames(text, _config.DmdWidth, _config.DmdHeight, useGrayscale);
             
             if (textFrames != null && textFrames.Count > 0)
             {
                 int frameDuration = 30; // ms
                 int textAnimDuration = textFrames.Count * frameDuration;
                 
                 // Cap text animation if it's too long? Or let it play fast?
                 // If total time is 10s, used 2s (cup), left 8s.
                 // Ideally text takes 3-4s.
                 // If text is long, it might take longer.
                 
                 await AnimateOverlayAsync(textFrames, frameDuration);
             }

             // 3. Show Badge (Remainder)
             // Calculation: Total - 2000 - TextTime (approx)
             // Actually SetOverlayAsync sets expiry relative to NOW.
             // So we just set it for a reasonable time, e.g. 5000ms. 
             // Workflow will naturally clear or it will expire.
             
             if (!string.IsNullOrEmpty(badgePath))
             {
                 await SetOverlayAsync(badgePath, 5000); // 5s final static
             }
        }

        private async Task AnimateOverlayAsync(List<byte[]> frames, int frameDurationMs)
        {
            foreach(var frame in frames)
            {
                 // Check if overlay was cancelled/replaced? 
                 // We rely on caller flow.
                 
                 // Fix for 16 shades
                 bool useGrayscale = _config.GetSetting("DmdForceMono", "false") == "true";
                 // ... (re-check wrapper if needed, but frames are already generated with grayscale flag)
                 // But wait, the 4-bit shift needs to happen if using Render_16_Shades logic dynamically?
                 // Frames generated by GenerateDmdScrollingTextFrames call GetRawDmdBytes which does NOT shift?
                 // DmdService usually shifts AFTER getting bytes.
                 // Let's assume frames are raw 8-bit. We need to shift if needed.
                 
                 var bytes = frame;
                 if (_isNativeOpen && _dmdWrapper.RenderMethodName?.Contains("16_Shades") == true && useGrayscale)
                 {
                     // Clone to avoid modifying cached list if reused? (List is local here)
                     // But strictly, GetRawDmdBytes might return new array. 
                     // Let's shift in place if we own the list.
                      for (int i = 0; i < bytes.Length; i++) bytes[i] = (byte)(bytes[i] >> 4);
                 }

                 lock(_overlayLock)
                 {
                     _activeOverlayBytes = bytes;
                     _overlayExpiry = DateTime.Now.AddMilliseconds(frameDurationMs + 50); // Buffer
                 }
                 
                 // If static mode, force render
                 if (_animationCts == null && _isNativeOpen)
                 {
                     // Force render static with overlay
                     RenderStaticWithOverlay(useGrayscale); 
                 }

                 await Task.Delay(frameDurationMs);
            }
        }

        public async Task SetOverlayAsync(string imagePath, int durationMs = 5000)
        {
            try
            {
                 // EN: Load overlay image as raw bytes (matched to current DMD format)
                 // FR: Charger l'image overlay en bytes bruts (adapté au format DMD actuel)
                 
                 bool useGrayscale = false;
                 if (_dmdWrapper.IsLoaded)
                 {
                     string methodName = _dmdWrapper.RenderMethodName ?? "";
                     if (methodName.Contains("16_Shades") || methodName.Contains("4_Shades") || 
                         methodName.Contains("Gray", StringComparison.OrdinalIgnoreCase) ||
                         methodName.Contains("Grey", StringComparison.OrdinalIgnoreCase))
                     {
                         useGrayscale = true;
                     }
                 }
                 if (_config.GetSetting("DmdForceMono", "false") == "true") useGrayscale = true;

                 var bytes = await _imageService.GetRawDmdBytes(imagePath, _config.DmdWidth, _config.DmdHeight, useGrayscale);
                 
                 if (bytes != null && bytes.Length > 0)
                 {
                     // Fix for Render_16_Shades (Native driver expects 4-bit for this specific method)
                     if (useGrayscale && (_dmdWrapper.RenderMethodName?.Contains("16_Shades") == true))
                     {
                         for (int i = 0; i < bytes.Length; i++) bytes[i] = (byte)(bytes[i] >> 4);
                     }
                     
                     lock(_overlayLock)
                     {
                         _activeOverlayBytes = bytes;
                         _overlayExpiry = DateTime.Now.AddMilliseconds(durationMs);
                     }
                     _logger.LogInformation($"[DMD] Overlay set for {durationMs}ms");

                     // EN: If no animation loop is running (Static Image), manually update display
                     // FR: Si aucune boucle d'animation (Image Statique), mettre à jour l'affichage manuellement
                     if (_animationCts == null && _isNativeOpen)
                     {
                         RenderStaticWithOverlay(useGrayscale);
                         
                         // Clean up later
                         _ = Task.Delay(durationMs).ContinueWith(_ => 
                         {
                             // Only restore if this overlay hasn't been replaced
                             lock(_overlayLock)
                             {
                                 if (_overlayExpiry <= DateTime.Now)
                                 {
                                     _activeOverlayBytes = null;
                                     if (_animationCts == null && _isNativeOpen) RenderStaticWithOverlay(useGrayscale);
                                 }
                             }
                         });
                     }
                 }
            }
            catch (Exception ex)
            {
                _logger.LogError($"[DMD] Failed to set overlay: {ex.Message}");
            }
        }
        
        /// <summary>
        /// EN: Clear active overlay immediately
        /// FR: Effacer l'overlay actif immédiatement
        /// </summary>
        public void ClearOverlay()
        {
            lock (_overlayLock)
            {
                _activeOverlayBytes = null;
                _overlayExpiry = DateTime.MinValue;
            }
            _logger.LogInformation("[DMD] Overlay cleared");
        }
        
        private void RenderStaticWithOverlay(bool useGrayscale)
        {
             try
             {
                 byte[]? baseBytes = _currentStaticBytes;
                 byte[]? overlay = _activeOverlayBytes;
                 
                 if (baseBytes == null) return; // Nothing to show?
                 
                 var bytesToSend = new byte[baseBytes.Length];
                 Array.Copy(baseBytes, bytesToSend, baseBytes.Length);
                 
                 if (overlay != null && overlay.Length == bytesToSend.Length)
                 {
                    // Composition Logic (Same as GIF loop)
                    int step = useGrayscale ? 1 : 3;
                    for (int k = 0; k < bytesToSend.Length; k += step)
                    {
                        bool isPixelNonBlack = false;
                        for (int s = 0; s < step; s++)
                        {
                            if (k + s < overlay.Length && overlay[k + s] != 0)
                            {
                                isPixelNonBlack = true;
                                break;
                            }
                        }

                        if (isPixelNonBlack)
                        {
                             for (int s = 0; s < step; s++)
                             {
                                 if (k + s < bytesToSend.Length) bytesToSend[k + s] = overlay[k + s];
                             }
                        }
                    }
                 }
                 
                 _dmdWrapper.Render((ushort)_config.DmdWidth, (ushort)_config.DmdHeight, bytesToSend);
             }
             catch(Exception ex)
             {
                 _logger.LogError($"[DMD] RenderStaticWithOverlay error: {ex.Message}");
             }
        }

        private void StartNativeGifAnimation(string path, bool useGrayscale)
        {
            StopAnimation();
            _animationCts = new CancellationTokenSource();
            var token = _animationCts.Token;

            _logger.LogInformation($"[DMD Native GIF] Starting high-performance animation for: {path}");

            Task.Run(async () =>
            {
                try
                {
                    // 1. Pre-decode & Pre-process all frames
                    var frames = new List<(byte[] bytes, int delayMs)>();

                    using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                    {
                        using (var gif = Image.FromStream(fs))
                        {
                            var dimension = new FrameDimension(gif.FrameDimensionsList[0]);
                            int frameCount = gif.GetFrameCount(dimension);
                            byte[]? delayBytes = null;
                            try { delayBytes = gif.GetPropertyItem(0x5100)?.Value; } catch { }

                            for (int i = 0; i < frameCount; i++)
                            {
                                if (token.IsCancellationRequested) return;
                                
                                gif.SelectActiveFrame(dimension, i);
                                
                                byte[] bytes;
                                using (var frameBmp = new Bitmap(gif))
                                {
                                    bytes = _imageService.GetRawDmdBytes(frameBmp, _config.DmdWidth, _config.DmdHeight, useGrayscale);
                                }

                                if (bytes != null && bytes.Length > 0)
                                {
                                    // Fix for Render_16_Shades (Native driver expects 4-bit for this specific method)
                                    if (useGrayscale && (_dmdWrapper.RenderMethodName?.Contains("16_Shades") == true))
                                    {
                                        for (int j = 0; j < bytes.Length; j++) bytes[j] = (byte)(bytes[j] >> 4);
                                    }

                                    int delayMs = 100;
                                    if (delayBytes != null && delayBytes.Length >= (i + 1) * 4)
                                    {
                                         delayMs = BitConverter.ToInt32(delayBytes, i * 4) * 10;
                                    }
                                    if (delayMs <= 0) delayMs = 100;

                                    frames.Add((bytes, delayMs));
                                }
                            }
                        }
                    }

                    if (frames.Count == 0 || token.IsCancellationRequested) return;

                    _logger.LogInformation($"[DMD Native GIF] Pre-cached {frames.Count} frames. Starting playback loop.");
                    
                    await EnsureNativeOpenAsync();

                    // 2. Playback Loop (Ultra Fast - no allocations)
                    while (!token.IsCancellationRequested)
                    {
                        foreach (var frame in frames)
                        {
                            if (token.IsCancellationRequested) break;

                            byte[] bytesToSend = frame.bytes;

                            // EN: Overlay Logic (Chroma Key Composition)
                            // FR: Logique Overlay (Composition Chroma Key)
                            byte[]? overlay = null;
                            lock(_overlayLock)
                            {
                                if (_activeOverlayBytes != null && _overlayExpiry > DateTime.Now)
                                {
                                    overlay = _activeOverlayBytes;
                                }
                                else if (_activeOverlayBytes != null)
                                {
                                    _activeOverlayBytes = null; // Expired
                                }
                            }

                            if (overlay != null && overlay.Length == bytesToSend.Length)
                            {
                                // EN: Create temporary buffer for composition to avoid modifying cached frame
                                // FR: Créer buffer temporaire pour éviter de modifier la frame en cache
                                var composed = new byte[bytesToSend.Length];
                                Array.Copy(bytesToSend, composed, bytesToSend.Length);
                                
                                // Chroma Key (Assume 0 = Black/Transparent)
                                // EN: Handle RGB vs Gray properly to avoid channel mixing
                                // FR: Gérer RGB vs Gray correctement pour éviter mélange de canaux
                                int step = useGrayscale ? 1 : 3;
                                
                                for (int k = 0; k < composed.Length; k += step)
                                {
                                    bool isPixelNonBlack = false;
                                    // Check if any component of pixel is non-zero
                                    for (int s = 0; s < step; s++)
                                    {
                                        if (k + s < overlay.Length && overlay[k + s] != 0)
                                        {
                                            isPixelNonBlack = true;
                                            break;
                                        }
                                    }

                                    if (isPixelNonBlack)
                                    {
                                        // Copy full pixel
                                        for (int s = 0; s < step; s++)
                                        {
                                            if (k + s < composed.Length) composed[k + s] = overlay[k + s];
                                        }
                                    }
                                }
                                bytesToSend = composed;
                            }

                            _dmdWrapper.Render((ushort)_config.DmdWidth, (ushort)_config.DmdHeight, bytesToSend);

                            // High-precision delay for fast animations
                            if (frame.delayMs < 16) 
                            { 
                                // Hybrid Wait: Sleep to save CPU, then Spin for precision
                                var sw = Stopwatch.StartNew();
                                
                                // Sleep while we have > 2ms remaining
                                while (sw.ElapsedMilliseconds < frame.delayMs - 2 && !token.IsCancellationRequested)
                                {
                                    Thread.Sleep(1); 
                                }
                                
                                // Spin for the final milliseconds
                                while (sw.ElapsedMilliseconds < frame.delayMs && !token.IsCancellationRequested) 
                                { 
                                    Thread.SpinWait(10); // Lightweight spin
                                }
                            }
                            else
                            {
                                await Task.Delay(frame.delayMs, token).ConfigureAwait(false);
                            }
                        }
                    }
                }
                catch (OperationCanceledException) { /* Normal exit */ }
                catch (Exception ex)
                {
                    _logger.LogError($"[DMD Native GIF] Animation Error: {ex.Message}");
                }
                finally
                {
                    _logger.LogInformation($"[DMD Native GIF] Animation stopped for: {path}");
                }
            }, token);
        }
    }
}
