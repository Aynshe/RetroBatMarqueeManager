using RetroBatMarqueeManager.Core.Interfaces;
using RetroBatMarqueeManager.Infrastructure.Native;
using System.Diagnostics;
using System.Text.RegularExpressions;
using System.Drawing;
using System.Drawing.Imaging;
using RetroBatMarqueeManager.Core.Models.RetroAchievements;

namespace RetroBatMarqueeManager.Application.Services
{
    public class DmdService : IDmdService, IDisposable
    {
        private readonly IConfigService _config;
        private readonly IProcessService _processService;
        private readonly ILogger<DmdService> _logger;
        private readonly ImageConversionService _imageService;
        private readonly DmdDeviceWrapper _dmdWrapper;

        private Process? _currentDmdProcess;
        private string _dmdDeviceIniPath;
        private bool _isNativeOpen = false;
        private string? _lastMediaPath = null;
        private CancellationTokenSource? _animationCts = null;
        private CancellationTokenSource? _overlayAnimationCts = null;
        private CancellationTokenSource? _rpLoopCts = null;
        private Task? _rpLoopTask = null;
        private List<byte[]>? _rpFrames = null;
        private bool _isExternalControlActive = false;

        public DmdService(
            IConfigService config, 
            IProcessService processService, 
            ImageConversionService imageService, 
            DmdDeviceWrapper dmdWrapper,
            ILogger<DmdService> logger)
        {
            _config = config;
            _processService = processService;
            _imageService = imageService;
            _dmdWrapper = dmdWrapper;
            _logger = logger;
            
            var dmdDir = Path.GetDirectoryName(config.DmdExePath);
            if (string.IsNullOrEmpty(dmdDir)) dmdDir = AppDomain.CurrentDomain.BaseDirectory;
            _dmdDeviceIniPath = Path.Combine(dmdDir, "DmdDevice.ini");
        }

        public async Task InitializeAsync()
        {
            if (!_config.DmdEnabled)
            {
                _logger.LogInformation("DMD support is disabled in config.");
                return;
            }

            // Always prepare config
            PrepareConfig();

            // Try to load Native DLL
            var dmdDir = Path.GetDirectoryName(_config.DmdExePath);
            if (!string.IsNullOrEmpty(dmdDir))
            {
                 if (_dmdWrapper.Load(dmdDir))
                 {
                     _logger.LogInformation("Native DMD Driver Loaded.");
                     _logger.LogInformation("Native DMD Driver Loaded.");
                     _isExternalControlActive = false;
                     await EnsureNativeOpenAsync();
                 }
                 else
                 {
                     _logger.LogWarning("Failed to load Native DMD Driver. Will fallback to CLI only.");
                 }
            }
            
            // Play Default Media on Startup
            if (!string.IsNullOrEmpty(_config.DefaultDmdPath) && File.Exists(_config.DefaultDmdPath))
            {
                _logger.LogInformation($"Playing Default DMD Media: {_config.DefaultDmdPath}");
                // Await default playback
                await PlayAsync(_config.DefaultDmdPath);
            }
        }

        public string PrepareConfig()
        {
             // EN: Update DmdDevice.ini intelligently (preserve other settings)
             // FR: Mettre à jour DmdDevice.ini intelligemment (préserver les autres paramètres)
             
             try
             {
                 var lines = new List<string>();
                 if (File.Exists(_dmdDeviceIniPath))
                 {
                     lines = File.ReadAllLines(_dmdDeviceIniPath).ToList();
                 }
                 else
                 {
                     // Create skeleton if missing
                     lines.Add("; Generated by RetroBatMarqueeManager");
                     lines.Add("[global]");
                     lines.Add("resize = 128x32");
                     lines.Add("flip_horizontally = false");
                     lines.Add("flip_vertically = false");
                     lines.Add("");
                 }
                 
                // Helper to update or insert key in section (and remove duplicates)
                 void UpdateKey(string section, string key, string value)
                 {
                     int sectionIdx = -1;
                     // Find section
                     for (int i = 0; i < lines.Count; i++)
                     {
                         if (lines[i].Trim().Equals($"[{section}]", StringComparison.OrdinalIgnoreCase))
                         {
                             sectionIdx = i;
                             break;
                         }
                     }
                     
                     if (sectionIdx == -1)
                     {
                         // Section missing, append it
                         lines.Add("");
                         lines.Add($"[{section}]");
                         lines.Add($"{key} = {value}");
                         return;
                     }
                     
                     // Scan keys in section
                     bool keyUpdated = false;
                     List<int> linesToRemove = new List<int>();
                     
                     for (int i = sectionIdx + 1; i < lines.Count; i++)
                     {
                         var line = lines[i].Trim();
                         if (line.StartsWith("[")) break; // End of section
                         
                         // Check for Key match (ignore comments starting with ;)
                         // We strictly match "key =" or "key="
                         if (line.StartsWith(key + " =", StringComparison.OrdinalIgnoreCase) || 
                             line.StartsWith(key + "=", StringComparison.OrdinalIgnoreCase))
                         {
                             if (!keyUpdated)
                             {
                                 lines[i] = $"{key} = {value}";
                                 keyUpdated = true;
                             }
                             else
                             {
                                 // Duplicate key found later in section! Remove it to prevent override.
                                 linesToRemove.Add(i);
                             }
                         }
                     }
                     
                     // Remove duplicates in reverse order
                     for (int j = linesToRemove.Count - 1; j >= 0; j--)
                     {
                         lines.RemoveAt(linesToRemove[j]);
                     }
                     
                     if (!keyUpdated)
                     {
                         lines.Insert(sectionIdx + 1, $"{key} = {value}");
                     }
                 }
                 
                // 1. GLOBAL: Update Resize
                // DmdDevice 2.0+ expects Fit, Fill, or Stretch. Legacy used WxH.
                // Reverting to WxH because 'Fit' causes crash with GIFs on VirtualDMD?
                // FR: Retour à WxH car 'Fit' semble planter le VirtualDMD avec des GIFs
                UpdateKey("global", "resize", "Fit");
                 
                // 2. MODELS: Enable/Disable based on selection
                var selectedModel = _config.DmdModel.ToLowerInvariant();
                
                // IMPORTANT: Map "virtual" to "virtualdmd" section for correct dot-matrix rendering
                // "virtual" section has upscaling which gives flat screen appearance
                // "virtualdmd" section gives proper DMD pixel/dot rendering
                if (selectedModel == "virtual")
                {
                    selectedModel = "virtualdmd";
                }
                
                // Comprehensive list of sections in DmdDevice.ini to manage
                var knownModels = new[] { 
                    "virtual", "virtualdmd", 
                    "pin2dmd", 
                    "zedmd", "zedmdhd", "zedmdwifi", "zedmdhdwifi", 
                    "pindmdv1", "pindmdv2", "pindmdv3", 
                    "pixelcade", "alphanumeric", 
                    "pinup", 
                    "rawoutput", 
                    "networkstream", "browserstream", "vpdbstream" 
                };
                 
                 foreach (var model in knownModels)
                 {
                     bool isEnabled = (model == selectedModel);
                     

                     
                     UpdateKey(model, "enabled", isEnabled ? "true" : "false");
                 }

                File.WriteAllLines(_dmdDeviceIniPath, lines);
                _logger.LogInformation($"Updated DmdDevice.ini: set global.resize=Fit, {selectedModel}.enabled=true (others false)");
                
                // CRITICAL: Set Variable in USER scope so external processes (PinballFX, etc.) can see it!
                // EN: External game processes need to find DmdDevice.ini via this env variable
                // FR: Les processus de jeux externes ont besoin de trouver DmdDevice.ini via cette variable
                Environment.SetEnvironmentVariable("DMDDEVICE_CONFIG", _dmdDeviceIniPath, EnvironmentVariableTarget.User);
                _logger.LogInformation($"Set DMDDEVICE_CONFIG environment variable (User scope): {_dmdDeviceIniPath}");
            }
            catch (Exception ex)
            {
                _logger.LogError($"Failed to update DmdDevice.ini: {ex.Message}");
            }
            
            return _dmdDeviceIniPath;
        }

        private async Task EnsureNativeOpenAsync()
        {
            if (!_dmdWrapper.IsLoaded) return;

            // If CLI process is running, stop it first to free device
            StopCliProcess();

            if (!_isNativeOpen)
            {
                 // EN: Add safety delay to ensure USB device is fully released by external process (dmdext)
                 // FR: Ajouter un délai de sécurité pour s'assurer que le périphérique USB est libéré par le processus externe
                 await Task.Delay(200);

                int result = _dmdWrapper.Open();
                if (result >= 0) // usually 0 or count on success 
                {
                    _isNativeOpen = true;
                    _logger.LogInformation("Native DMD Device Opened.");

                    // EN: Send a CLEAR frame immediately to reset hardware state (Fix for ZeDMD screen frozen/black)
                    // FR: Envoyer une frame CLEAR immédiatement pour réinitialiser l'état du matériel
                    try 
                    {
                        var clearBytes = new byte[_config.DmdWidth * _config.DmdHeight * 3]; // Black (Zeros)
                        _dmdWrapper.Render((ushort)_config.DmdWidth, (ushort)_config.DmdHeight, clearBytes);
                        _logger.LogInformation("[DMD] Sent Clear Frame on Open.");
                    }
                    catch (Exception ex)
                    {
                        _logger.LogWarning($"[DMD] Failed to send Clear Frame: {ex.Message}");
                    }
                }
                else
                {
                    _logger.LogError($"Failed to Open Native DMD Device. Result code: {result}");
                }
            }
        }

        private void EnsureNativeClosed()
        {
            if (_isNativeOpen)
            {
                _dmdWrapper.Close();
                _isNativeOpen = false;
                _logger.LogInformation("Native DMD Device Closed.");
            }
        }

        private void StopCliProcess()
        {
            if (_currentDmdProcess != null && !_currentDmdProcess.HasExited)
            {
                try
                {
                    _currentDmdProcess.Kill();
                    _currentDmdProcess.Dispose();
                }
                catch (Exception ex)
                {
                    _logger.LogWarning($"Failed to kill DMD CLI process: {ex.Message}");
                }
                finally
                {
                    _currentDmdProcess = null;
                }
            }
             // Ensure stray dmdext fallback
            try { _processService.KillProcess("dmdext"); } catch {}
        }

        public async Task PlayAsync(string mediaPath, string? system = null, string? gameName = null)
        {
            await PlayInternalAsync(mediaPath, system, gameName);
        }

        // Switched to Async internally but keeping Interface void for now (or fire-and-forget)
        private async Task PlayInternalAsync(string mediaPath, string? system = null, string? gameName = null)
        {
            if (string.IsNullOrEmpty(mediaPath)) return;
            
            // Optimization: If same media is already playing, don't restart
            if (_lastMediaPath == mediaPath && (_isNativeOpen || (_currentDmdProcess != null && !_currentDmdProcess.HasExited) || _animationCts != null))
            {
                return;
            }

            // EN: Protection against overriding external processes (e.g., Pinball)
            // FR: Protection contre l'écrasement de processus externes (ex: Pinball)
            if (_isExternalControlActive)
            {
                _logger.LogWarning($"[DMD Protected] Leaving DMD alone because external control is active. Request for '{Path.GetFileName(mediaPath)}' ignored.");
                return;
            }

            _lastMediaPath = mediaPath;

            // Fix: Clean state for new playback
            StopCliProcess();
            StopAnimation();

            if (!_config.DmdEnabled) return;
            if (!File.Exists(mediaPath)) return;

            string ext = Path.GetExtension(mediaPath).TrimStart('.').ToLowerInvariant();
            bool isVideo = new[] { "gif", "mp4", "avi", "webm", "mkv" }.Contains(ext);
            
            _logger.LogInformation($"[DMD Play] Request: {mediaPath} (Ext={ext}, IsVideo={isVideo}, NativeLoaded={_dmdWrapper.IsLoaded})");
            
            // Special handling for MP4: User requests conversion to Animated GIF for cached playback
            if (ext == "mp4")
            {
                var processedPath = _imageService.ProcessDmdImage(mediaPath, "defaults", system, gameName);
                if (!string.IsNullOrEmpty(processedPath) && File.Exists(processedPath))
                {
                    mediaPath = processedPath;
                    ext = Path.GetExtension(mediaPath).TrimStart('.').ToLowerInvariant();
                    isVideo = new[] { "gif", "mp4", "avi", "webm", "mkv" }.Contains(ext);
                }
                else
                {
                    _logger.LogWarning($"[DMD Play] MP4 conversion failed for {mediaPath}. Aborting playback (dmdext does not support raw MP4).");
                    return;
                }
            }

            if (_dmdWrapper.IsLoaded)
            {
                // Determine grayscale mode
                bool useGrayscale = false;
                string methodName = _dmdWrapper.RenderMethodName ?? "";
                if (methodName.Contains("16_Shades") || methodName.Contains("4_Shades") || 
                    methodName.Contains("Gray", StringComparison.OrdinalIgnoreCase) ||
                    methodName.Contains("Grey", StringComparison.OrdinalIgnoreCase))
                {
                    useGrayscale = true;
                }
                if (_config.GetSetting("DmdForceMono", "false") == "true")
                {
                    useGrayscale = true;
                }

                if (ext == "gif")
                {
                    // NATIVE GIF PATH (0 Latency)
                    StartNativeGifAnimation(mediaPath, useGrayscale);
                    return;
                }

                if (!isVideo)
                {
                    // NATIVE STATIC PATH
                    await EnsureNativeOpenAsync();
                    try 
                    {
                        var bytes = await _imageService.GetRawDmdBytes(mediaPath, _config.DmdWidth, _config.DmdHeight, useGrayscale);
                        if (bytes != null && bytes.Length > 0)
                        {
                             // Fix for Render_16_Shades
                             if (useGrayscale && (_dmdWrapper.RenderMethodName?.Contains("16_Shades") == true))
                             {
                                 for (int i = 0; i < bytes.Length; i++) bytes[i] = (byte)(bytes[i] >> 4);
                             }
                             
                             _currentStaticBytes = bytes; // Store for overlay composition
                             RenderStaticWithOverlay(useGrayscale); // Use RenderStaticWithOverlay to handle active overlay
                        }
                    }
                    catch (Exception ex) { _logger.LogError($"Native Render Error: {ex.Message}"); }
                    return;
                }
            }

            // CLI PATH (Fallback for Video or if Native failed)
            EnsureNativeClosed(); 
            StartCliProcess(mediaPath);
        }

        public async Task<(bool handled, bool suspendMPV)> CheckAndRunPinballAsync(string system, string gameName)
        {
            if (!_config.DmdEnabled) return (false, false);

            var command = _config.GetSetting(system);
            if (string.IsNullOrWhiteSpace(command)) return (false, false);

            // EN: Parse format: command[;handleDMD][;suspendMPV]
            // FR: Parser le format : commande[;handleDMD][;suspendMPV]
            var parts = command.Split(';');
            var actualCommand = parts[0].Trim();
            var handleDMD = parts.Length > 1 && parts[1].Trim().Equals("True", StringComparison.OrdinalIgnoreCase);
            var suspendMPV = parts.Length > 2 && parts[2].Trim().Equals("True", StringComparison.OrdinalIgnoreCase);

            _logger.LogInformation($"[Pinball] System '{system}' match found. Command: {actualCommand}, HandleDMD: {handleDMD}, SuspendMPV: {suspendMPV}");

            if (actualCommand.Equals("True", StringComparison.OrdinalIgnoreCase))
            {
                _logger.LogInformation($"[Pinball] External handling requested for '{system}'. Internal DMD stopped. SuspendMPV: {suspendMPV}");
                // stop internal DMD
                Stop();
                _isExternalControlActive = true;
                _logger.LogInformation("[DMD Protected] External control activated.");
                return (true, suspendMPV);
            }

            // Replace Placeholders
            actualCommand = actualCommand.Replace("{DmdModel}", _config.DmdModel, StringComparison.OrdinalIgnoreCase)
                             .Replace("{GameName}", gameName, StringComparison.OrdinalIgnoreCase);

            // Zaccaria Position Logic
            if (actualCommand.Contains("!POSITION!"))
            {
                var pos = await GetZaccariaPosition(gameName);
                if (!string.IsNullOrEmpty(pos))
                {
                    actualCommand = actualCommand.Replace("!POSITION!", pos);
                }
                else
                {
                    _logger.LogWarning($"[Pinball] Could not find position for '{gameName}' in Zaccaria positions.txt. Aborting.");
                    return (true, suspendMPV); 
                }
            }

            // Launch Command
            try
            {
                _logger.LogInformation($"[Pinball] Launching Custom Command: {actualCommand}");
                
                var cmdParts = actualCommand.Split(" ", 2);
                var fileName = cmdParts[0];
                var args = cmdParts.Length > 1 ? cmdParts[1] : "";

                if (fileName.Equals("dmdext.exe", StringComparison.OrdinalIgnoreCase))
                {
                    fileName = _config.DmdExePath;
                    
                    // EN: Special fix for Zaccaria Pinball: Ensure --quit-when-done is present if not already
                    // FR: Fix spécial pour Zaccaria Pinball : S'assurer que --quit-when-done est présent
                    if (system.Contains("zaccaria", StringComparison.OrdinalIgnoreCase) && 
                        !args.Contains("--quit-when-done", StringComparison.OrdinalIgnoreCase))
                    {
                         args += " --quit-when-done";
                         _logger.LogInformation("[Pinball] Automatically added --quit-when-done for Zaccaria Pinball.");
                    }
                }

                // EN: Close native driver to release DMD device for CLI process
                // FR: Fermer le driver natif pour libérer le périphérique DMD pour le processus CLI
                StopAnimation(); // Ensure internal animation is stopped
                EnsureNativeClosed();
                
                // EN: Wait for ZeDMD full restart (takes 1-2 seconds for hardware reset)
                // FR: Attendre le redémarrage complet du ZeDMD (1-2 secondes pour reset matériel)
                // _logger.LogInformation("[Pinball] Waiting 2s for ZeDMD restart...");
                // await Task.Delay(2000); // Optimized: User confirmed delay might not be needed.
                await Task.Delay(100); // Small safety buffer only
                
                _logger.LogInformation("[Pinball] Launching CLI command...");
                
                if (StartCliProcessCustom(fileName, args))
                {
                    _isExternalControlActive = true;
                    _logger.LogInformation("[DMD Protected] External control activated (CLI launched).");
                }
                else
                {
                    _logger.LogWarning("[Pinball] Failed to launch CLI command - DMD Protection NOT activated.");
                    _isExternalControlActive = false; // Ensure it's false
                }
                
                // EN: Try to bring game window to front if it lost focus during launch
                // FR: Essayer de remettre la fenêtre du jeu au premier plan si elle a perdu le focus au lancement
                // Using system name as heuristic for process name if needed, or Zaccaria specifically
                if (system.Contains("zaccaria", StringComparison.OrdinalIgnoreCase))
                {
                    // "ZaccariaPinball.exe" is the usual name
                    await Task.Delay(500); // Wait a bit for window activation if any
                    _processService.FocusProcess("ZaccariaPinball"); 
                }
                
                return (true, suspendMPV);
            }
            catch (Exception ex)
            {
                _logger.LogError($"[Pinball] Failed to launch custom command: {ex.Message}");
                return (true, suspendMPV);
            }
        }

        private async Task<string?> GetZaccariaPosition(string gameName)
        {
            try
            {
                var dmdDir = Path.GetDirectoryName(_config.DmdExePath);
                if (string.IsNullOrEmpty(dmdDir)) return null;

                var posFile = Path.Combine(dmdDir, "zaccariapinball", "positions.txt");
                if (!File.Exists(posFile))
                {
                    _logger.LogWarning($"[Pinball] Positions file not found: {posFile}");
                    return null;
                }

                var lines = await File.ReadAllLinesAsync(posFile);
                foreach (var line in lines)
                {
                    // Format: GameName:Position
                    // Example: Game Name:100 100 500 200
                    var parts = line.Split(':', 2);
                    if (parts.Length == 2)
                    {
                        if (parts[0].Trim().Equals(gameName, StringComparison.OrdinalIgnoreCase))
                        {
                            return parts[1].Trim();
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"[Pinball] Error reading positions.txt: {ex.Message}");
            }
            return null;
        }

        private bool StartCliProcessCustom(string fileName, string args)
        {
             StopCliProcess();

             try
             {
                var startInfo = new ProcessStartInfo
                {
                    FileName = fileName,
                    Arguments = args,
                    UseShellExecute = false,
                    CreateNoWindow = true,
                    WorkingDirectory = AppDomain.CurrentDomain.BaseDirectory,
                    RedirectStandardError = true,
                    RedirectStandardOutput = true
                };
                
                // Pass environment config for dmdext
                startInfo.EnvironmentVariables["DMDDEVICE_CONFIG"] = _dmdDeviceIniPath;

                _currentDmdProcess = new Process { StartInfo = startInfo };
                _currentDmdProcess.EnableRaisingEvents = true; // Enable Exited event

                _currentDmdProcess.OutputDataReceived += (s, e) => { if (e.Data != null) _logger.LogInformation($"[DMD EXT (Custom) STDOUT] {e.Data}"); };
                _currentDmdProcess.ErrorDataReceived += (s, e) => { if (e.Data != null) _logger.LogError($"[DMD EXT (Custom) STDERR] {e.Data}"); };
                _currentDmdProcess.Exited += (s, e) => 
                {
                    _logger.LogWarning($"[DMD EXT (Custom)] Process exited with code: {_currentDmdProcess.ExitCode}");
                    _isExternalControlActive = false; // Release lock if process dies
                };

                _currentDmdProcess.Start();

                _currentDmdProcess.BeginOutputReadLine();
                _currentDmdProcess.BeginErrorReadLine();
                
                return true;
             }
             catch(Exception ex)
             {
                 _logger.LogError($"[Pinball] StartCliProcessCustom Failed: {ex.Message}");
                 return false;
             }
        }

        private void StartCliProcess(string mediaPath)
        {
            StopCliProcess(); // Stop previous

             try
            {
                var args = $"play -f \"{mediaPath}\"";
                
                // --- ARGUMENT GENERATION ---
                // "Si commenté [empty] -> Mode Automatique. Si décommenté [value] -> Mode Autonome"
                
                string userArgs = _config.DmdArguments; // Sanitized by IDmdConfigService logic regarding --format if present

                if (!string.IsNullOrWhiteSpace(userArgs))
                {
                    // MANUAL MODE (Partial or Full Autonomy)
                    // We append what the user provided.
                    // We DO NOT add -d automatically, assuming user might have provided it or wants default.
                    // We DO NOT add position/stay-on-top defaults.
                    
                    // Safety: Sanitize --format if it crept in, as it crashes 'play'
                    var cleanArgs = userArgs
                        .Replace("--format rgb24", "", StringComparison.OrdinalIgnoreCase)
                        .Replace("--format", "", StringComparison.OrdinalIgnoreCase);

                    args += $" {cleanArgs}";
                    _logger.LogDebug($"[DMD CLI] Manual Arguments Used: {cleanArgs}");
                }
                else
                {
                    // AUTO MODE (Default)
                    
                    var model = _config.DmdModel.ToLowerInvariant();
                    
                    // Check if this is a virtual/software DMD or physical hardware
                    var virtualModels = new[] { "virtual", "virtualdmd" };
                    bool isVirtualModel = virtualModels.Contains(model);
                    
                    if (isVirtualModel)
                    {
                        // VIRTUAL DMD: Use --virtual-position (no -d flag needed for play command)
                        // According to official documentation, --virtual-position automatically enables virtual DMD
                        
                        // Calculate window size using DmdDotSize as scaling factor
                        // This allows keeping DmdWidth/Height as rendering resolution (128x32)
                        // while displaying in a larger window (e.g., 1024x256 with DmdDotSize=8)
                        int windowWidth = (int)(_config.DmdWidth * _config.DmdDotSize);
                        int windowHeight = (int)(_config.DmdHeight * _config.DmdDotSize);
                        
                        // Position & Options
                        args += $" --virtual-position 0 0 {windowWidth} {windowHeight} --virtual-stay-on-top";
                    }
                    else
                    {
                        // PHYSICAL HARDWARE DMD: Use -d flag with the configured model
                        // Examples: zedmd, pin2dmd, pindmdv3, etc.
                        args += $" -d {model}";
                        _logger.LogInformation($"[DMD CLI] Using hardware destination: {model}");
                    }
                }
                
                _logger.LogInformation($"[DMD CLI] Launching: {_config.DmdExePath} {args}");
                
                var startInfo = new ProcessStartInfo
                {
                    FileName = _config.DmdExePath,
                    Arguments = args,
                    UseShellExecute = false,
                    CreateNoWindow = true, 
                    WorkingDirectory = AppDomain.CurrentDomain.BaseDirectory,
                    RedirectStandardError = true,
                    RedirectStandardOutput = true
                };

                startInfo.EnvironmentVariables["DMDDEVICE_CONFIG"] = _dmdDeviceIniPath;

                _currentDmdProcess = new Process { StartInfo = startInfo };
                
                _currentDmdProcess.OutputDataReceived += (s, e) => { if (e.Data != null) _logger.LogInformation($"[DMD EXT STDOUT] {e.Data}"); };
                _currentDmdProcess.ErrorDataReceived += (s, e) => { if (e.Data != null) _logger.LogError($"[DMD EXT STDERR] {e.Data}"); };

                _currentDmdProcess.Start();
                
                _currentDmdProcess.BeginOutputReadLine(); // Drain buffers to avoid lock
                _currentDmdProcess.BeginErrorReadLine();
            }
            catch (Exception ex)
            {
                _logger.LogError($"Failed to start DMD CLI: {ex.Message}");
            }
        }

        public async Task WaitForExternalReleaseAsync(int timeoutMs = 2000)
        {
            // EN: Safety check: If lock is active but no process is running (Manual Mode or Crash), release immediately.
            // FR: Vérification de sécurité : Si le verrou est actif mais qu'aucun processus ne tourne, libérer immédiatement.
            bool isProcessRunning = false;
            try 
            {
                if (_currentDmdProcess != null && !_currentDmdProcess.HasExited) isProcessRunning = true;
            } 
            catch {}

            if (_isExternalControlActive && !isProcessRunning)
            {
                _logger.LogInformation("[DMD] External control active but no managed process running (Manual Mode detected). Force releasing.");
                _isExternalControlActive = false;
            }

            if (!_isExternalControlActive)
            {
                await EnsureNativeOpenAsync();
                return;
            }

            _logger.LogInformation($"[DMD] Waiting up to {timeoutMs}ms for external control release...");
            int elapsed = 0;
            int interval = 50;
            while (_isExternalControlActive && elapsed < timeoutMs)
            {
                await Task.Delay(interval);
                elapsed += interval;
            }

            if (_isExternalControlActive)
            {
                 _logger.LogWarning("[DMD] Timeout waiting for external control release. Forcing takeover.");
                 StopCliProcess(); // Kill any stuck process
                 _isExternalControlActive = false;
                 await EnsureNativeOpenAsync();
            }
            else
            {
                _logger.LogInformation("[DMD] External control released.");
                // EN: Proactively open native driver to reset hardware
                // FR: Ouvrir proactivement le driver natif pour réinitialiser le matériel
                await EnsureNativeOpenAsync();
            }
        }

        public void Stop()
        {
            _isExternalControlActive = false; // Reset protection on explicit Stop()
            StopCliProcess();
            StopAnimation();
            EnsureNativeClosed(); // EN: Also close native driver to fully release DMD device / FR: Fermer aussi le driver natif pour libérer complètement le périphérique DMD
        }

        public void Dispose()
        {
            StopCliProcess();
            StopAnimation();
            EnsureNativeClosed();
            _dmdWrapper.Dispose();
            GC.SuppressFinalize(this);
        }

        private void StopAnimation()
        {
            try
            {
                if (_animationCts != null)
                {
                    _animationCts.Cancel();
                    _animationCts.Dispose();
                    _animationCts = null;
                }
                if (_overlayAnimationCts != null)
                {
                    _overlayAnimationCts.Cancel();
                    _overlayAnimationCts.Dispose();
                    _overlayAnimationCts = null;
                }
            }
            catch (Exception ex)
            {
                _logger.LogWarning($"Error stopping DMD animation: {ex.Message}");
            }
        }

        private byte[]? _activeOverlayBytes;
        private DateTime? _overlayExpiry;
        private readonly object _overlayLock = new object();
        private byte[]? _persistentScoreBytes; // EN: Persistent score overlay / FR: Overlay du score permanent
        private readonly object _scoreLock = new object();
        private byte[]? _currentStaticBytes; // Store current static image for composition
        
        public async Task SetDmdPersistentScoreAsync(string scoreText)
        {
            try
            {
                bool useGrayscale = _config.GetSetting("DmdForceMono", "false") == "true";
                if (_isNativeOpen && _dmdWrapper.IsLoaded)
                {
                    var method = _dmdWrapper.RenderMethodName ?? "";
                    if (method.Contains("Gray") || method.Contains("16_Shades") || method.Contains("4_Shades")) useGrayscale = true;
                }

                var bytes = _imageService.GenerateDmdPersistentScoreFrame(scoreText, _config.DmdWidth, _config.DmdHeight, useGrayscale);
                
                lock(_scoreLock)
                {
                    _persistentScoreBytes = bytes;
                }

                // Trigger render refresh if in static mode
                if (_animationCts == null && _isNativeOpen)
                {
                    RenderStaticWithOverlay(useGrayscale); 
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"[DMD] SetDmdPersistentScoreAsync error: {ex.Message}");
            }
            await Task.CompletedTask;
        }

        public async Task SetDmdPersistentLayoutAsync(byte[] layoutBytes)
        {
            try
            {
                lock(_scoreLock)
                {
                    _persistentScoreBytes = layoutBytes;
                }

                // Trigger render refresh
                if (_animationCts == null && _isNativeOpen)
                {
                    bool useGrayscale = _config.GetSetting("DmdForceMono", "false") == "true";
                    if (_isNativeOpen && _dmdWrapper.IsLoaded)
                    {
                        var method = _dmdWrapper.RenderMethodName ?? "";
                        if (method.Contains("Gray") || method.Contains("16_Shades") || method.Contains("4_Shades")) useGrayscale = true;
                    }
                    RenderStaticWithOverlay(useGrayscale); 
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"[DMD] SetDmdPersistentLayoutAsync error: {ex.Message}");
            }
            await Task.CompletedTask;
        }

        public async Task PlayAchievementSequenceAsync(string cupPath, string achOverlayPath, int totalDurationMs = 10000)
        {
             lock(_overlayLock) { _isSequencePlaying = true; }
             
             try
             {
                 // 1. Show Cup (2s)
                 if (!string.IsNullOrEmpty(cupPath) && File.Exists(cupPath))
                 {
                     _logger.LogInformation($"[DMD Sequence] Playing Cup: {cupPath}");
                     await SetOverlayAsync(cupPath, 2000);
                     await Task.Delay(2000);
                 }
                 else
                 {
                     _logger.LogWarning($"[DMD Sequence] Cup path missing or invalid: {cupPath}");
                 }
                 
                 // 2. Show Composite Overlay (Remainder)
                 if (!string.IsNullOrEmpty(achOverlayPath))
                 {
                     if (File.Exists(achOverlayPath))
                     {
                         var info = new FileInfo(achOverlayPath);
                         _logger.LogInformation($"[DMD Sequence] Playing Achievement Overlay: {achOverlayPath} (Size: {info.Length} bytes)");
                         
                         await SetOverlayAsync(achOverlayPath, 8000); // 8s final static (Total ~10s)
                         await Task.Delay(8000);
                     }
                     else
                     {
                          _logger.LogWarning($"[DMD Sequence] Achievement Overlay file not found: {achOverlayPath}");
                     }
                 }
                 else
                 {
                     _logger.LogWarning("[DMD Sequence] Achievement Overlay path is null/empty.");
                 }
             }
             catch(Exception ex)
             {
                 _logger.LogError($"[DMD Sequence] Error: {ex.Message}");
             }
             finally
             {
                 lock(_overlayLock) { _isSequencePlaying = false; }
                 _logger.LogInformation("[DMD Sequence] Finished.");
             }
        }

        private bool _isSequencePlaying = false;

        public async Task PlayRichPresenceNotificationAsync(string text, int durationMs = 5000, int? yOverride = null, int? heightOverride = null, string? textColor = null, float? fontSize = null)
        {
             // EN: Check if an achievement sequence is currently playing
             // FR: Vérifier si une séquence de succès est en cours
             bool isBusy = false;
             lock(_overlayLock) { isBusy = _isSequencePlaying; }

             if (isBusy) 
             {
                 // EN: Skip or delay? User said "it must display after".
                 // But RP updates are fleeting. If we delay, the data might be stale.
                 // However, "Lives: 0" isn't stale quickly.
                 // Simple approach: Just skip RP update if busy with Achievement? 
                 // Or wait?
                 // User: "il doit s'afficher apres" (it must display after).
                 // We will wait slightly. 
                 
                 // Note: Waiting here blocks the caller (Workflow). That loops per event. It's OK to wait a bit.
                 // But indefinite wait is bad.
                 // Let's simplified approach: If busy, we queue it? 
                 // For now, let's just RETURN if busy to avoid cutting off the important achievement.
                 // OR, better: Wait for it to finish?
                 // Let's wait up to 10s.
                 
                 int retries = 0;
                 while(isBusy && retries < 20) // 10s max
                 {
                     await Task.Delay(500);
                     lock(_overlayLock) { isBusy = _isSequencePlaying; }
                     retries++;
                 }
                 
                 if (isBusy) return; // Gave up
             }

             try
             {
                 // EN: Generate scrolling text frames for RP
                 // FR: Générer les frames de texte défilant pour RP
                 bool useGrayscale = _config.GetSetting("DmdForceMono", "false") == "true";
                 if (_isNativeOpen && _dmdWrapper.IsLoaded)
                 {
                     var method = _dmdWrapper.RenderMethodName ?? "";
                     if (method.Contains("Gray") || method.Contains("16_Shades") || method.Contains("4_Shades")) useGrayscale = true;
                 }

                  int targetH = heightOverride ?? (_config.DmdHeight / 2);
                  int yPos = yOverride ?? ((_config.DmdHeight / 2) - 1);
                  var textFrames = _imageService.GenerateDmdScrollingTextFrames(text, _config.DmdWidth, _config.DmdHeight, useGrayscale, yOffset: yPos, targetHeight: targetH, textColor: textColor, fontSizeParam: fontSize);
                 
                  if (textFrames != null && textFrames.Count > 0)
                  {
                      _rpFrames = textFrames;
                      
                      // EN: Ensure the RP loop is running / FR: S'assurer que la boucle RP tourne
                     if (_rpLoopTask == null || _rpLoopTask.IsCompleted)
                     {
                         _rpLoopCts = new CancellationTokenSource();
                         _rpLoopTask = RunRpLoopAsync(_rpLoopCts.Token);
                     }
                 }
             }
             catch (Exception ex)
             {
                 _logger.LogError($"[DMD] Error starting RP loop: {ex.Message}");
             }
        }

        private async Task RunRpLoopAsync(CancellationToken token)
        {
            _logger.LogInformation("[DMD] RP Loop Started");
            try
            {
                while (!token.IsCancellationRequested)
                {
                    // EN: Check if we are busy with an achievement sequence
                    // FR: Vérifier si on est occupé par une séquence de succès
                    bool isBusy = false;
                    lock(_overlayLock) { isBusy = _isSequencePlaying; }
                    
                    if (isBusy)
                    {
                        await Task.Delay(1000, token);
                        continue;
                    }

                    List<byte[]>? currentFrames = _rpFrames;
                    if (currentFrames == null || currentFrames.Count == 0)
                    {
                        await Task.Delay(1000, token);
                        continue;
                    }

                    // EN: Play one full pass of the scroll (20ms for faster movement)
                    // FR: Jouer un passage complet du défilement (20ms pour un mouvement plus rapide)
                    // EN: We use the main loop token here to let the current pass finish before checking for new frames
                    // FR: On utilise le token de boucle principal pour laisser la passe actuelle se finir avant de vérifier les nouvelles frames
                    await AnimateOverlayAsync(currentFrames, 20, token);
                    
                    if (currentFrames.Count > 1)
                    {
                        // EN: If it was a scroll (multiple frames), stop after one pass until the next value update
                        // FR: Si c'était un défilement (plusieurs frames), arrêter après un passage jusqu'à la prochaine mise à jour
                        _rpFrames = null;
                        ClearOverlay();
                        continue;
                    }

                    // EN: Small pause at end of pass for static or single-frame items
                    // FR: Petite pause à la fin du passage pour les items statiques
                    await Task.Delay(300, token);
                }
            }
            catch (OperationCanceledException) { }
            catch (Exception ex)
            {
                _logger.LogWarning($"[DMD] RP Loop Error: {ex.Message}");
            }
            _logger.LogInformation("[DMD] RP Loop Stopped");
        }

        public async Task PlayDmdStaticNotificationAsync(string text, int durationMs = 3000)
        {
             bool isBusy = false;
             lock(_overlayLock) { isBusy = _isSequencePlaying; }
             if (isBusy) 
             {
                 int retries = 0;
                 while(isBusy && retries < 20) // 10s max
                 {
                     await Task.Delay(500);
                     lock(_overlayLock) { isBusy = _isSequencePlaying; }
                     retries++;
                 }
                 if (isBusy) return;
             }

             try
             {
                 bool useGrayscale = _config.GetSetting("DmdForceMono", "false") == "true";
                 if (_isNativeOpen && _dmdWrapper.IsLoaded)
                 {
                     var method = _dmdWrapper.RenderMethodName ?? "";
                     if (method.Contains("Gray") || method.Contains("16_Shades") || method.Contains("4_Shades")) useGrayscale = true;
                 }

                 int halfHeight = _config.DmdHeight / 2;
                 int yPos = halfHeight - 1;
                 var frame = _imageService.GenerateDmdStaticTextFrame(text, _config.DmdWidth, _config.DmdHeight, useGrayscale, yOffset: yPos, targetHeight: halfHeight);
                  if (frame != null)
                  {
                      _rpFrames = new List<byte[]> { frame };

                      // EN: Ensure the RP loop is running / FR: S'assurer que la boucle RP tourne
                     if (_rpLoopTask == null || _rpLoopTask.IsCompleted)
                     {
                         _rpLoopCts = new CancellationTokenSource();
                         _rpLoopTask = RunRpLoopAsync(_rpLoopCts.Token);
                     }
                 }
             }
             catch (Exception ex)
             {
                 _logger.LogError($"[DMD] Error in PlayDmdStaticNotificationAsync: {ex.Message}");
             }
        }

        public async Task PlayChallengeNotificationAsync(ChallengeState state, bool isHardcore = false, string? ribbonPath = null)
        {
             // EN: Check if an achievement sequence is currently playing
             // FR: Vérifier si une séquence de succès est en cours
             bool isBusy = false;
             lock(_overlayLock) { isBusy = _isSequencePlaying; }

             if (isBusy) return; // Priority to Unlock

             if (!state.IsActive)
             {
                 // Challenge Ended -> Clear
                 ClearOverlay();
                 return;
             }

             // EN: Generate image for DMD (dynamic timer/count)
             // FR: Générer image pour DMD (timer/compteur dynamique)
             bool useGrayscale = _config.GetSetting("DmdForceMono", "false") == "true";
             if (_isNativeOpen && _dmdWrapper.IsLoaded)
             {
                 var method = _dmdWrapper.RenderMethodName ?? "";
                 if (method.Contains("Gray") || method.Contains("16_Shades") || method.Contains("4_Shades")) useGrayscale = true;
             }

             var imagePath = _imageService.GenerateDmdChallengeImage(state, _config.DmdWidth, _config.DmdHeight, useGrayscale, isHardcore, ribbonPath);
             
             if (!string.IsNullOrEmpty(imagePath) && File.Exists(imagePath))
             {
                 // EN: Duration is long but it will be updated by the refresh loop in MarqueeWorkflow
                 // FR: La durée est longue mais elle sera mise à jour par la boucle de rafraîchissement dans MarqueeWorkflow
                 await SetOverlayAsync(imagePath, 3600000); // 1 hour persistent until clear
             }
        }

        public async Task PlayFullPreviewAsync()
        {
            try
            {
                bool useGrayscale = _config.GetSetting("DmdForceMono", "false") == "true";
                if (_isNativeOpen && _dmdWrapper.IsLoaded)
                {
                    var method = _dmdWrapper.RenderMethodName ?? "";
                    if (method.Contains("Gray") || method.Contains("16_Shades") || method.Contains("4_Shades")) useGrayscale = true;
                }

                var bytes = _imageService.GenerateDmdFullPreviewFrame(_config.DmdWidth, _config.DmdHeight, useGrayscale);
                if (bytes != null && bytes.Length > 0)
                {
                    lock(_overlayLock)
                    {
                        _activeOverlayBytes = bytes;
                        _overlayExpiry = DateTime.Now.AddSeconds(30); // Show preview for 30s
                    }

                    if (_animationCts == null && _isNativeOpen)
                    {
                        RenderStaticWithOverlay(useGrayscale); 
                    }
                    _logger.LogInformation("[DMD] Full Preview triggered.");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"[DMD] PlayFullPreviewAsync Error: {ex.Message}");
            }
            await Task.CompletedTask;
        }

        private async Task AnimateOverlayAsync(List<byte[]> frames, int frameDurationMs, CancellationToken token = default, bool isSequence = false)
        {
            for (int i = 0; i < frames.Count; i++)
            {
                if (token.IsCancellationRequested) return;

                // EN: If a priority sequence is playing, stop RP animation / FR: Si une séquence prioritaire tourne, arrêter l'anim RP
                if (!isSequence && _isSequencePlaying) return;

                // Fix for 16 shades
                bool useGrayscale = _config.GetSetting("DmdForceMono", "false") == "true";
                
                var bytes = frames[i];
                if (_isNativeOpen && _dmdWrapper.RenderMethodName?.Contains("16_Shades") == true && useGrayscale)
                {
                    // Copy to avoid modifying the source list if it's shared
                    var tintedBytes = new byte[bytes.Length];
                    Array.Copy(bytes, tintedBytes, bytes.Length);
                    for (int j = 0; j < tintedBytes.Length; j++) tintedBytes[j] = (byte)(tintedBytes[j] >> 4);
                    bytes = tintedBytes;
                }

                lock(_overlayLock)
                {
                    _activeOverlayBytes = bytes;
                    // EN: If it's the last frame, keep it longer to cover the pause between passes/loops (default 1500ms)
                    // FR: Si c'est la dernière frame, la garder plus longtemps pour couvrir la pause entre les passages (défaut 1500ms)
                    int extraBuffer = (i == frames.Count - 1) ? 2000 : 50;
                    _overlayExpiry = DateTime.Now.AddMilliseconds(frameDurationMs + extraBuffer);
                }
                
                if (_animationCts == null && _isNativeOpen)
                {
                    RenderStaticWithOverlay(useGrayscale); 
                }

                await Task.Delay(frameDurationMs, token);
            }
        }

        public async Task SetOverlayAsync(string imagePath, int durationMs = 5000)
        {
            try
            {
                 // EN: Load overlay image as raw bytes (matched to current DMD format)
                 // FR: Charger l'image overlay en bytes bruts (adapté au format DMD actuel)
                 
                 bool useGrayscale = false;
                 if (_dmdWrapper.IsLoaded)
                 {
                     string methodName = _dmdWrapper.RenderMethodName ?? "";
                     if (methodName.Contains("16_Shades") || methodName.Contains("4_Shades") || 
                         methodName.Contains("Gray", StringComparison.OrdinalIgnoreCase) ||
                         methodName.Contains("Grey", StringComparison.OrdinalIgnoreCase))
                     {
                         useGrayscale = true;
                     }
                 }
                if (_config.GetSetting("DmdForceMono", "false") == "true") useGrayscale = true;

                 // EN: Check for GIF (Animated Overlay)
                 if (imagePath.EndsWith(".gif", StringComparison.OrdinalIgnoreCase) && File.Exists(imagePath))
                 {
                     StartOverlayAnimation(imagePath, durationMs, useGrayscale);
                     return;
                 }

                 var bytes = await _imageService.GetRawDmdBytes(imagePath, _config.DmdWidth, _config.DmdHeight, useGrayscale);
                 
                 if (bytes != null && bytes.Length > 0)
                 {
                     // Fix for Render_16_Shades (Native driver expects 4-bit for this specific method)
                     if (useGrayscale && (_dmdWrapper.RenderMethodName?.Contains("16_Shades") == true))
                     {
                         for (int i = 0; i < bytes.Length; i++) bytes[i] = (byte)(bytes[i] >> 4);
                     }
                     
                     lock(_overlayLock)
                     {
                         _activeOverlayBytes = bytes;
                         _overlayExpiry = DateTime.Now.AddMilliseconds(durationMs);
                     }
                     _logger.LogInformation($"[DMD] Overlay set for {durationMs}ms");

                     // EN: If no animation loop is running (Static Image), manually update display
                     // FR: Si aucune boucle d'animation (Image Statique), mettre à jour l'affichage manuellement
                     if (_animationCts == null && _isNativeOpen)
                     {
                         RenderStaticWithOverlay(useGrayscale);
                         
                         // Clean up later
                         _ = Task.Delay(durationMs).ContinueWith(_ => 
                         {
                             // Only restore if this overlay hasn't been replaced
                             lock(_overlayLock)
                             {
                                 if (_overlayExpiry <= DateTime.Now)
                                 {
                                     _activeOverlayBytes = null;
                                     if (_animationCts == null && _isNativeOpen) RenderStaticWithOverlay(useGrayscale);
                                 }
                             }
                         });
                     }
                 }
            }
            catch (Exception ex)
            {
                _logger.LogError($"[DMD] Failed to set overlay: {ex.Message}");
            }
        }

        private void StartOverlayAnimation(string imagePath, int durationMs, bool useGrayscale)
        {
            // Cancel previous overlay animation
            _overlayAnimationCts?.Cancel();
            _overlayAnimationCts = new CancellationTokenSource();
            var token = _overlayAnimationCts.Token;

            Task.Run(async () =>
            {
                try
                {
                    var frames = new List<(byte[] bytes, int delayMs)>();

                    using (var gif = Image.FromFile(imagePath))
                    {
                        var dimension = new FrameDimension(gif.FrameDimensionsList[0]);
                        int frameCount = gif.GetFrameCount(dimension);
                        byte[]? delayBytes = null;
                        try { delayBytes = gif.GetPropertyItem(0x5100)?.Value; } catch { }

                        for (int i = 0; i < frameCount; i++)
                        {
                            if (token.IsCancellationRequested) return;
                            gif.SelectActiveFrame(dimension, i);
                            
                            using (var frameBmp = new Bitmap(gif))
                            {
                                var bytes = _imageService.GetRawDmdBytes(frameBmp, _config.DmdWidth, _config.DmdHeight, useGrayscale);
                                if (bytes != null)
                                {
                                    // Fix for Render_16_Shades (Native driver expects 4-bit)
                                    if (useGrayscale && (_dmdWrapper.RenderMethodName?.Contains("16_Shades") == true))
                                    {
                                        for (int j = 0; j < bytes.Length; j++) bytes[j] = (byte)(bytes[j] >> 4);
                                    }

                                    int delay = 100;
                                    if (delayBytes != null && delayBytes.Length >= (i + 1) * 4)
                                        delay = BitConverter.ToInt32(delayBytes, i * 4) * 10;
                                    
                                    if (delay < 20) delay = 100; // Sanity check
                                    frames.Add((bytes, delay));
                                }
                            }
                        }
                    }

                    if (frames.Count == 0 || token.IsCancellationRequested) return;

                    var startTime = DateTime.Now;
                    var endTime = startTime.AddMilliseconds(durationMs);

                    _logger.LogInformation($"[DMD Overlay] Starting animation loop ({frames.Count} frames) for {durationMs}ms");

                    // Set Expiry for the lock logic
                    lock (_overlayLock) { _overlayExpiry = endTime; }

                    while (DateTime.Now < endTime && !token.IsCancellationRequested)
                    {
                        foreach (var frame in frames)
                        {
                            if (token.IsCancellationRequested || DateTime.Now >= endTime) break;

                            lock (_overlayLock)
                            {
                                _activeOverlayBytes = frame.bytes;
                            }

                            // If main content is static, we must trigger a render here to show the overlay update
                            if (_animationCts == null && _isNativeOpen)
                            {
                                RenderStaticWithOverlay(useGrayscale);
                            }

                            await Task.Delay(frame.delayMs, token);
                        }
                    }
                }
                catch (OperationCanceledException) { }
                catch (Exception ex)
                {
                    _logger.LogError($"[DMD Overlay] Animation error: {ex.Message}");
                }
                finally
                {
                    // Clean up
                    lock (_overlayLock)
                    {
                        // ensure we don't clear if a NEW overlay started
                         if (!token.IsCancellationRequested) 
                        {
                            _activeOverlayBytes = null;
                            // Trigger final render to clear
                            if (_animationCts == null && _isNativeOpen) RenderStaticWithOverlay(useGrayscale);
                        }
                        else
                        {
                            // EN: Even if cancelled, if no new overlay was set (null), we must clear
                            // FR: Même si annulé, si aucun nouvel overlay n'a été défini (null), on doit effacer
                            if (_activeOverlayBytes == null && _animationCts == null && _isNativeOpen)
                            {
                                RenderStaticWithOverlay(useGrayscale);
                            }
                        }
                    }
                }
            });
        }
        
        /// <summary>
        /// EN: Clear active overlay immediately
        /// FR: Effacer l'overlay actif immédiatement
        /// </summary>
        public void ClearOverlay()
        {
            lock (_overlayLock)
            {
                _activeOverlayBytes = null;
                _overlayExpiry = DateTime.MinValue;
                _overlayAnimationCts?.Cancel();
                _rpLoopCts?.Cancel();
                _rpFrames = null;
            }
            
            // EN: Force immediate re-render to clear the screen physically
            // FR: Forcer un re-rendu immédiat pour effacer l'écran physiquement
            if (_animationCts == null && _isNativeOpen)
            {
                // Re-determine grayscale mode cleanly
                bool useGrayscale = _config.GetSetting("DmdForceMono", "false") == "true";
                 if (_isNativeOpen && _dmdWrapper.IsLoaded)
                 {
                     var method = _dmdWrapper.RenderMethodName ?? "";
                     if (method.Contains("Gray") || method.Contains("16_Shades") || method.Contains("4_Shades")) useGrayscale = true;
                 }
                RenderStaticWithOverlay(useGrayscale);
            }

            _logger.LogInformation("[DMD] Overlay cleared and Render triggered");
        }
        
        private void RenderStaticWithOverlay(bool useGrayscale)
        {
             try
             {
                 byte[]? baseBytes = _currentStaticBytes;
                 byte[]? overlay = null;
                 byte[]? score = null;

                 lock(_overlayLock)
                 {
                     if (_activeOverlayBytes != null && _overlayExpiry > DateTime.Now) overlay = _activeOverlayBytes;
                 }
                 lock(_scoreLock)
                 {
                     score = _persistentScoreBytes;
                 }
                 
                 if (baseBytes == null) return; // Nothing to show?
                 
                 var bytesToSend = new byte[baseBytes.Length];
                 Array.Copy(baseBytes, bytesToSend, baseBytes.Length);
                 
                 int step = useGrayscale ? 1 : 3;

                 // 1. Composite Persistent Score first / FR: Composer d'abord le score persistant
                 if (score != null && score.Length == bytesToSend.Length)
                 {
                     for (int k = 0; k < bytesToSend.Length; k += step)
                     {
                         bool isPixelNonBlack = false;
                         for (int s = 0; s < step; s++) { if (k + s < score.Length && score[k + s] != 0) { isPixelNonBlack = true; break; } }
                         if (isPixelNonBlack) { for (int s = 0; s < step; s++) { if (k + s < bytesToSend.Length) bytesToSend[k + s] = score[k + s]; } }
                     }
                 }

                 // 2. Composite Temporary Notification on top / FR: Composer la notification temporaire par dessus
                 if (overlay != null && overlay.Length == bytesToSend.Length)
                 {
                     for (int k = 0; k < bytesToSend.Length; k += step)
                     {
                         bool isPixelNonBlack = false;
                         for (int s = 0; s < step; s++) { if (k + s < overlay.Length && overlay[k + s] != 0) { isPixelNonBlack = true; break; } }
                         if (isPixelNonBlack) { for (int s = 0; s < step; s++) { if (k + s < bytesToSend.Length) bytesToSend[k + s] = overlay[k + s]; } }
                     }
                 }
                 
                 _dmdWrapper.Render((ushort)_config.DmdWidth, (ushort)_config.DmdHeight, bytesToSend);
             }
             catch(Exception ex)
             {
                 _logger.LogError($"[DMD] RenderStaticWithOverlay error: {ex.Message}");
             }
        }

        private void StartNativeGifAnimation(string path, bool useGrayscale)
        {
            StopAnimation();
            _animationCts = new CancellationTokenSource();
            var token = _animationCts.Token;

            _logger.LogInformation($"[DMD Native GIF] Starting high-performance animation for: {path}");

            Task.Run(async () =>
            {
                try
                {
                    // 1. Pre-decode & Pre-process all frames
                    var frames = new List<(byte[] bytes, int delayMs)>();

                    using (var fs = new FileStream(path, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                    {
                        using (var gif = Image.FromStream(fs))
                        {
                            var dimension = new FrameDimension(gif.FrameDimensionsList[0]);
                            int frameCount = gif.GetFrameCount(dimension);
                            byte[]? delayBytes = null;
                            try { delayBytes = gif.GetPropertyItem(0x5100)?.Value; } catch { }

                            for (int i = 0; i < frameCount; i++)
                            {
                                if (token.IsCancellationRequested) return;
                                
                                gif.SelectActiveFrame(dimension, i);
                                
                                byte[] bytes;
                                using (var frameBmp = new Bitmap(gif))
                                {
                                    bytes = _imageService.GetRawDmdBytes(frameBmp, _config.DmdWidth, _config.DmdHeight, useGrayscale);
                                }

                                if (bytes != null && bytes.Length > 0)
                                {
                                    // Fix for Render_16_Shades (Native driver expects 4-bit for this specific method)
                                    if (useGrayscale && (_dmdWrapper.RenderMethodName?.Contains("16_Shades") == true))
                                    {
                                        for (int j = 0; j < bytes.Length; j++) bytes[j] = (byte)(bytes[j] >> 4);
                                    }

                                    int delayMs = 100;
                                    if (delayBytes != null && delayBytes.Length >= (i + 1) * 4)
                                    {
                                         delayMs = BitConverter.ToInt32(delayBytes, i * 4) * 10;
                                    }
                                    if (delayMs <= 0) delayMs = 100;

                                    frames.Add((bytes, delayMs));
                                }
                            }
                        }
                    }

                    if (frames.Count == 0 || token.IsCancellationRequested) return;

                    _logger.LogInformation($"[DMD Native GIF] Pre-cached {frames.Count} frames. Starting playback loop.");
                    
                    await EnsureNativeOpenAsync();

                    // 2. Playback Loop (Ultra Fast - no allocations)
                    while (!token.IsCancellationRequested)
                    {
                        foreach (var frame in frames)
                        {
                            if (token.IsCancellationRequested) break;

                            byte[] bytesToSend = frame.bytes;

                            // EN: Overlay Logic (Multi-layer Composition)
                            // FR: Logique Overlay (Composition multi-couches)
                            byte[]? overlay = null;
                            byte[]? score = null;
                            
                            lock(_overlayLock)
                            {
                                if (_activeOverlayBytes != null && _overlayExpiry > DateTime.Now) overlay = _activeOverlayBytes;
                                else if (_activeOverlayBytes != null) _activeOverlayBytes = null; // Expired
                            }
                            lock(_scoreLock)
                            {
                                score = _persistentScoreBytes;
                            }

                            if ((overlay != null && overlay.Length == bytesToSend.Length) || (score != null && score.Length == bytesToSend.Length))
                            {
                                // EN: Create temporary buffer for composition to avoid modifying cached frame
                                // FR: Créer buffer temporaire pour éviter de modifier la frame en cache
                                var composed = new byte[bytesToSend.Length];
                                Array.Copy(bytesToSend, composed, bytesToSend.Length);
                                
                                int step = useGrayscale ? 1 : 3;
                                
                                // 1. Score Layer / FR: Couche Score
                                if (score != null && score.Length == composed.Length)
                                {
                                    for (int k = 0; k < composed.Length; k += step)
                                    {
                                        bool isPixelNonBlack = false;
                                        for (int s = 0; s < step; s++) { if (k + s < score.Length && score[k + s] != 0) { isPixelNonBlack = true; break; } }
                                        if (isPixelNonBlack) { for (int s = 0; s < step; s++) { if (k + s < composed.Length) composed[k + s] = score[k + s]; } }
                                    }
                                }

                                // 2. Notification Layer (On Top) / FR: Couche Notification (Au dessus)
                                if (overlay != null && overlay.Length == composed.Length)
                                {
                                    for (int k = 0; k < composed.Length; k += step)
                                    {
                                        bool isPixelNonBlack = false;
                                        for (int s = 0; s < step; s++) { if (k + s < overlay.Length && overlay[k + s] != 0) { isPixelNonBlack = true; break; } }
                                        if (isPixelNonBlack) { for (int s = 0; s < step; s++) { if (k + s < composed.Length) composed[k + s] = overlay[k + s]; } }
                                    }
                                }
                                bytesToSend = composed;
                            }

                            _dmdWrapper.Render((ushort)_config.DmdWidth, (ushort)_config.DmdHeight, bytesToSend);

                            // High-precision delay for fast animations
                            if (frame.delayMs < 16) 
                            { 
                                // Hybrid Wait: Sleep to save CPU, then Spin for precision
                                var sw = Stopwatch.StartNew();
                                
                                // Sleep while we have > 2ms remaining
                                while (sw.ElapsedMilliseconds < frame.delayMs - 2 && !token.IsCancellationRequested)
                                {
                                    Thread.Sleep(1); 
                                }
                                
                                // Spin for the final milliseconds
                                while (sw.ElapsedMilliseconds < frame.delayMs && !token.IsCancellationRequested) 
                                { 
                                    Thread.SpinWait(10); // Lightweight spin
                                }
                            }
                            else
                            {
                                await Task.Delay(frame.delayMs, token).ConfigureAwait(false);
                            }
                        }
                    }
                }
                catch (OperationCanceledException) { /* Normal exit */ }
                catch (Exception ex)
                {
                    _logger.LogError($"[DMD Native GIF] Animation Error: {ex.Message}");
                }
                finally
                {
                    _logger.LogInformation($"[DMD Native GIF] Animation stopped for: {path}");
                }
            }, token);
        }
    }
}
